<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>{{ app_name }} — Drive</title>
  <link href="{{ url_for('static', filename='output.css') }}" rel="stylesheet">
</head>
<body class="bg-white">

  <!-- Header -->
  <header class="card shadow-soft sticky top-0 z-40">
    <div class="max-w-6xl mx-auto px-4 py-3 flex items-center gap-3">
      <img src="{{ url_for('static', filename='koala.jpg') }}" alt="koala" class="h-10 w-10 rounded-full border border-[var(--border)] shadow-subtle">
      <div class="flex-1">
        <h1 class="text-xl md:text-2xl font-semibold text-[var(--ink)] leading-tight heading">{{ app_name }}</h1>
        <p class="text-xs md:text-sm text-[var(--ink-2)]/70">Private web drive with share links</p>
      </div>
      <a href="/notes" class="hidden md:inline px-3 py-1.5 rounded-xl btn">Notes</a>
      <button id="btn-logout" class="hidden md:inline px-3 py-1.5 rounded-xl btn">Logout</button>
    </div>
  </header>

  <!-- Login -->
  <div id="login" class="min-h-[70vh] md:min-h-[75vh] flex items-center justify-center px-4">
    <div class="card p-6 md:p-8 rounded-2xl w-full max-w-sm shadow-soft">
      <h2 class="text-2xl font-semibold mb-6 text-[var(--ink)] text-center heading">Sign in</h2>
      <form id="login-form" class="space-y-4">
        <div>
          <label class="block text-sm mb-1 text-[var(--ink-2)]">Username</label>
          <input id="u" autocomplete="username" class="w-full input p-2.5 focus:outline-none focus:ring-2 focus:ring-[var(--accent)]">
        </div>
        <div>
          <label class="block text-sm mb-1 text-[var(--ink-2)]">Password</label>
          <input id="p" type="password" autocomplete="current-password" class="w-full input p-2.5 focus:outline-none focus:ring-2 focus:ring-[var(--accent)]">
        </div>
        <button class="w-full btn-primary rounded-xl p-2.5 font-semibold transition-colors">
          Continue
        </button>
        <p id="err" class="text-[var(--warn)] text-xs mt-2 text-center"></p>
      </form>
    </div>
  </div>

  <!-- Drive -->
  <main id="drive" class="hidden max-w-6xl mx-auto p-4 md:p-6 space-y-4">

    <!-- Toolbar -->
    <section class="card rounded-2xl p-3 md:p-4 shadow-soft">
      <div class="flex flex-col md:flex-row md:items-center gap-3">
        <nav id="crumbs" class="flex items-center flex-wrap text-sm gap-x-2"></nav>
        <div class="flex-1"></div>
        <div class="flex items-center gap-2">
          <div class="relative">
            <input id="search" placeholder="Search in folder…" class="w-48 md:w-64 input pl-9 pr-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-[var(--accent)]">
            <span class="absolute left-2 top-1.5 opacity-60">🔎</span>
          </div>
          <div class="inline-flex rounded-xl border border-[var(--border)] overflow-hidden">
            <button id="view-grid" class="px-3 py-2 text-sm btn">Grid</button>
            <button id="view-list" class="px-3 py-2 text-sm btn">List</button>
          </div>
        </div>
      </div>

      <div class="mt-3 flex flex-wrap items-center gap-2">
        <button id="btn-up" class="px-3 py-2 rounded-xl btn">⬆ Up</button>
        <button id="btn-mkdir" class="px-3 py-2 rounded-xl btn">＋ New Folder</button>
        <label class="px-3 py-2 rounded-xl btn cursor-pointer">
          ＋ Add files<input id="file" type="file" class="hidden" multiple>
        </label>

        <!-- Selection actions -->
        <div id="sel-actions" class="hidden flex-wrap gap-2 items-center ml-auto">
          <span id="sel-count" class="text-sm px-2 py-1 rounded-lg input"></span>
          <button id="sel-dl"   class="px-3 py-2 rounded-xl btn">Download Each</button>
          <button id="sel-mv"   class="px-3 py-2 rounded-xl btn">Move…</button>
          <button id="sel-cp"   class="px-3 py-2 rounded-xl btn">Copy…</button>
          <button id="sel-del"  class="px-3 py-2 rounded-xl btn-danger">Delete</button>
          <button id="sel-clear" class="px-3 py-2 rounded-xl btn">Clear</button>
        </div>

        <span id="cwd" class="text-xs md:text-sm opacity-80 ml-auto"></span>
        <a href="/notes" class="md:hidden px-3 py-2 rounded-xl btn">Notes</a>
        <button id="btn-logout-mobile" class="md:hidden px-3 py-2 rounded-xl btn">Logout</button>
      </div>
    </section>

    <!-- File area -->
    <section id="list" class="rounded-2xl card shadow-soft p-0"></section>

    <!-- Upload queue -->
    <section id="queue-wrap" class="fixed right-3 bottom-3 left-3 md:left-auto md:w-96 space-y-2 pointer-events-none"></section>
  </main>

  <!-- Context menu -->
  <div id="ctx" class="ctx"></div>

  <!-- Drag overlay -->
  <div id="dropzone" class="drop-overlay">
    <div class="card px-8 py-10 text-center shadow-soft">
      <div class="text-2xl mb-2">Drop files to upload</div>
      <div class="text-[var(--ink-2)]">They’ll be uploaded to the current folder</div>
    </div>
  </div>

  <!-- Preview modal -->
  <div id="preview" class="hidden fixed inset-0 bg-black/50 z-50 items-center justify-center">
    <div class="card rounded-xl max-w-4xl w-[92vw] max-h-[90vh] overflow-auto p-4 shadow-soft">
      <div class="flex justify-between items-center mb-3">
        <div id="preview-title" class="font-medium truncate"></div>
        <button id="preview-close" class="px-3 py-1.5 rounded-lg btn">Close</button>
      </div>
      <div id="preview-body" class="text-center"></div>
    </div>
  </div>

<script>
/* ===== Basics ===== */
const loginDiv = document.getElementById('login');
const driveDiv = document.getElementById('drive');
const errEl    = document.getElementById('err');
let clickTimer = null;
const CLICK_DELAY = 300; // ms

async function api(url, opts){
  const r = await fetch(url, opts);
  const t = await r.text();
  let j; try{ j = JSON.parse(t); }catch(e){ throw new Error(t.slice(0,200)); }
  if(!r.ok || j.ok===false || j.success===false) throw new Error(j.error || j.message || ('HTTP '+r.status));
  return j;
}

const params = new URLSearchParams(location.search);
const startPath = params.get('path') || '/';

let dlFrame = null;
function ensureDlFrame(){
  if (!dlFrame) {
    dlFrame = document.createElement('iframe');
    dlFrame.style.display = 'none';
    document.body.appendChild(dlFrame);
  }
}


async function checkStatus(){
  try{
    const s = await api('/auth/status');
    if(s.logged_in){ loginDiv.classList.add('hidden'); driveDiv.classList.remove('hidden'); load(startPath || '/', false); }
  }catch{}
}
checkStatus();

document.getElementById('login-form').addEventListener('submit', async (e)=>{
  e.preventDefault(); errEl.textContent='';
  const username = document.getElementById('u').value;
  const password = document.getElementById('p').value;
  try{
    await api('/auth/login', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({username,password})});
    loginDiv.classList.add('hidden'); driveDiv.classList.remove('hidden'); load(startPath || '/', false);
  }catch(ex){ errEl.textContent = ex.message; }
});

const logout = async ()=>{ await api('/auth/logout', {method:'POST'}); location.reload(); };
document.getElementById('btn-logout').onclick = logout;
document.getElementById('btn-logout-mobile').onclick = logout;

/* ===== Drive UI ===== */
const listEl = document.getElementById('list');
const cwdEl  = document.getElementById('cwd');
const crumbsEl = document.getElementById('crumbs');
const ctx    = document.getElementById('ctx');
const queueWrap = document.getElementById('queue-wrap');
const searchEl = document.getElementById('search');

const selWrap = document.getElementById('sel-actions');
const selCount= document.getElementById('sel-count');
const selDl   = document.getElementById('sel-dl');
const selMv   = document.getElementById('sel-mv');
const selCp   = document.getElementById('sel-cp');
const selDel  = document.getElementById('sel-del');
const selClear= document.getElementById('sel-clear');

let currentPath = '/';
let currentItems = [];
let viewMode = 'grid'; // 'grid' | 'list'
let ctxTarget = null;

let selected = new Set();
let lastAnchorIndex = null;

const isTouch = ('ontouchstart' in window) || window.matchMedia('(pointer: coarse)').matches;

document.getElementById('view-grid').onclick = ()=>{ viewMode='grid'; renderList(); };
document.getElementById('view-list').onclick = ()=>{ viewMode='list'; renderList(); };

function fmtBytes(b){ const u=['B','KB','MB','GB','TB']; let i=0; while(b>=1024&&i<u.length-1){b/=1024;i++;} return `${b.toFixed(1)} ${u[i]}`; }

function buildCrumbs(p){
  const parts = (p||'/').split('/').filter(Boolean);
  crumbsEl.innerHTML='';
  const push = (html)=>{ const span=document.createElement('span'); span.innerHTML=html; crumbsEl.appendChild(span); };
  push(`<a class="text-[var(--accent-2)] hover:underline" data-jump="/">Home</a>`);
  let acc = '';
  parts.forEach((seg)=>{
    acc += '/'+seg;
    push(`<span class="opacity-50">›</span>`);
    push(`<a class="hover:underline" data-jump="${acc}">${seg}</a>`);
  });
  crumbsEl.querySelectorAll('[data-jump]').forEach(a=>{
    a.addEventListener('click', (e)=>{ e.preventDefault(); clearSelection(); load(a.getAttribute('data-jump')); });
  });
}

searchEl.addEventListener('input', ()=> renderList());

async function load(path, push=true){
  const j = await api('/api/list?path='+encodeURIComponent(path||''));
  currentPath = (j.type==='dir' ? j.path : path);
  cwdEl.textContent = 'Path: ' + (currentPath||'/');
  buildCrumbs(currentPath||'/');

  if(j.type==='file'){
    // NEVER auto-download on click; only double-click / open via code path
    return;
  }
  currentItems = j.items || [];
  selected.clear(); updateSelUI();

  renderList();

  if (push) {
    const qs = currentPath==='/' ? '' : '?path='+encodeURIComponent(currentPath);
    history.pushState({path: currentPath}, '', qs);
  }
}

function downloadSelectedSequential(){
  const items = filteredItems();
  const paths = currentSelectionArray()
    .map(p => ({ p, it: items.find(i=>i.path===p) }))
    .filter(x => x.it && x.it.type === 'file')
    .map(x => x.p);

  if (paths.length === 0) return;

  // Single file: <a download> is snappier
  if (paths.length === 1) {
    const a = document.createElement('a');
    a.href = '/api/download?path=' + encodeURIComponent(paths[0]);
    a.download = '';
    document.body.appendChild(a);
    a.click();
    a.remove();
    return;
  }

  // Multiple files: hidden iframe, staggered
  ensureDlFrame();
  let i = 0;
  const step = () => {
    if (i >= paths.length) return;
    dlFrame.src = '/api/download?path=' + encodeURIComponent(paths[i++]);
    setTimeout(step, 700); // small delay per file
  };
  step();
}

function filteredItems(){
  const q = searchEl.value?.toLowerCase().trim() || '';
  return q ? currentItems.filter(it => it.name.toLowerCase().includes(q)) : currentItems;
}

/* === TEMPLATES (badge only when selected) === */
function rowTemplate(it, idx){
  const d = new Date(it.mtime*1000).toLocaleString();
  const isSel = selected.has(it.path);
  return `<div class="row grid grid-cols-12 px-3 py-2 cursor-default ${isSel?'selected':''}" data-index="${idx}" data-path="${it.path}" data-type="${it.type}">
    <div class="col-span-7 flex items-center gap-2 truncate">
      ${isSel?'<span class="badge">✓</span>':''}
      ${it.type==='dir'?'📁':'📄'} <span class="truncate">${it.name}</span>
    </div>
    <div class="col-span-2">${it.type==='dir'?'—':fmtBytes(it.size)}</div>
    <div class="col-span-3 flex items-center justify-between">
      <span class="text-[var(--ink-2)]/70">${d}</span>
      <button class="kebab rounded flex items-center justify-center" data-menu="${it.path}">⋮</button>
    </div>
  </div>`;
}

function tileTemplate(it, idx){
  const d = new Date(it.mtime*1000).toLocaleDateString();
  const icon = it.type==='dir'?'📁':'📄';
  const isSel = selected.has(it.path);
  return `<div class="tile relative group rounded-2xl card p-3 shadow-subtle transition ${isSel?'selected':''}"
              data-index="${idx}" data-path="${it.path}" data-type="${it.type}">
    ${isSel?'<div class="badge">✓</div>':''}
    <div class="flex items-start justify-between">
      <div class="text-3xl">${icon}</div>
      <button class="kebab rounded flex items-center justify-center" data-menu="${it.path}">⋮</button>
    </div>
    <div class="mt-2 font-medium truncate" title="${it.name}">${it.name}</div>
    <div class="text-xs text-[var(--ink-2)]/70 mt-1">${it.type==='dir'?'Folder':fmtBytes(it.size)} • ${d}</div>
  </div>`;
}

function renderList(){
  const items = filteredItems();
  if(viewMode==='list'){
    let html = `<div class="grid grid-cols-12 bg-[var(--muted)] px-3 py-2 text-sm border-b border-[var(--border)]">
      <div class="col-span-7">Name</div><div class="col-span-2">Size</div><div class="col-span-3">Modified</div></div>`;
    html += items.map((it,i)=>rowTemplate(it,i)).join('');
    listEl.innerHTML = html;
  } else {
    const grid = items.map((it,i)=>tileTemplate(it,i)).join('');
    listEl.innerHTML = `<div class="p-3 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3">${grid}</div>`;
  }
}

function itemFromEvent(e){
  const el = e.target.closest('[data-path]');
  if(!el) return null;
  const idx = Number(el.dataset.index);
  const it  = filteredItems()[idx];
  return { el, idx, item: it };
}

/* ===== Selection & UI ===== */
function updateSelUI(){
  const n = selected.size;
  if(n>0){
    selWrap.classList.remove('hidden');
    selCount.textContent = `${n} selected`;
  } else {
    selWrap.classList.add('hidden');
    selCount.textContent = '';
  }
  const items = filteredItems();
  const hasDir = [...selected].some(p => (items.find(i=>i.path===p)?.type === 'dir'));
  selDl.classList.toggle('disabled', selected.size === 0 || hasDir);

}
function clearSelection(){ selected.clear(); updateSelUI(); renderList(); }
function selectToggle(path){ selected.has(path) ? selected.delete(path) : selected.add(path); updateSelUI(); }
function selectRange(fromIdx, toIdx){
  const items = filteredItems();
  const [a,b] = fromIdx < toIdx ? [fromIdx,toIdx] : [toIdx,fromIdx];
  for(let i=a;i<=b;i++){ selected.add(items[i].path); }
  updateSelUI();
}

/* ===== Context Menu ===== */
function openCtx(path, x, y, type){
  // if something else is selected and target not in selection, make target the selection
  if(selected.size > 0 && !selected.has(path)){ selected.clear(); selected.add(path); updateSelUI(); renderList(); }

  const items = filteredItems();
  const selPaths = selected.size ? [...selected] : [path];
  const hasDir = selPaths.some(p => {
    const it = items.find(i=>i.path===p);
    return it && it.type === 'dir';
  });

  ctxTarget = { path, type };
  ctx.innerHTML = `
    <a onclick="openItem()">Open / Preview</a>
    <a ${hasDir ? 'class="disabled" aria-disabled="true"' : ''} onclick="downloadSelectedSequential()">Download</a>
    <a onclick="shareItem()">Share…</a>
    <a onclick="renameItem()">Rename…</a>
    <a onclick="propsItem()">Properties</a>
    <hr style="border:none;border-top:1px solid var(--border)">
    <a onclick="mkdirHere()">New Folder</a>
    <a onclick="moveItem()">Move…</a>
    <a onclick="copyItem()">Copy…</a>
    <a onclick="deleteItem()">Delete</a>`;
  ctx.style.left = x+'px';
  ctx.style.top  = y+'px';
  ctx.style.display='block';
}

document.addEventListener('click', (e)=>{ if(!ctx.contains(e.target)) ctx.style.display='none'; });

/* ===== Desktop interactions ===== */
listEl.addEventListener('dblclick', (e)=>{
  if (isTouch) return;
  if (clickTimer) { clearTimeout(clickTimer); clickTimer = null; }
  const h = itemFromEvent(e); if (!h) return;
  if (h.item.type === 'dir') load(h.item.path); else openPreview(h.item.path);
});
// Kebab -> context
listEl.addEventListener('click', (e)=>{
  if (isTouch) return;
  // ignore clicks on kebab or context UI
  if (e.target.closest('[data-menu]')) return;

  const h = itemFromEvent(e); if (!h) return;

  if (clickTimer) clearTimeout(clickTimer);
  clickTimer = setTimeout(()=>{
    if (e.shiftKey && lastAnchorIndex != null) {
      selectRange(lastAnchorIndex, h.idx);
    } else if (e.ctrlKey || e.metaKey) {
      selectToggle(h.item.path);
      lastAnchorIndex = h.idx;
    } else {
      selected.clear();
      selected.add(h.item.path);
      lastAnchorIndex = h.idx;
    }
    updateSelUI();
    renderList();
    clickTimer = null;
  }, CLICK_DELAY);
});

// Right-click
listEl.addEventListener('contextmenu', (e)=>{
  e.preventDefault();
  const h = itemFromEvent(e);
  if(!h){ ctx.style.display='none'; return; }
  openCtx(h.item.path, e.pageX, e.pageY, h.item.type);
});

/* ===== Touch interactions: tap=open, drag=select, long-press=context ===== */
let lpTimer = null, lpFired = false;
let dragSelecting = false;
let lastTouchedPath = null;
let touchStartX = 0, touchStartY = 0;
let touchMoved = false;
let suppressNextClick = false;
let pendingTouchSelectionToggle = false;
let touchSelectionModifier = false;
const DRAG_THRESHOLD = 12; // px movement before a drag-select begins

function clearLongPressTimer(){
  if (lpTimer) { clearTimeout(lpTimer); lpTimer = null; }
}

if (isTouch) {
  listEl.addEventListener('click', (e)=>{
    if (e.target.closest('[data-menu]')) return;
    if (suppressNextClick) {
      suppressNextClick = false;
      lpFired = false;
      pendingTouchSelectionToggle = false;
      return;
    }
    if (lpFired) { lpFired = false; return; }

    const h = itemFromEvent(e); if(!h) return;

    const modifierActive = pendingTouchSelectionToggle || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey;
    pendingTouchSelectionToggle = false;

    if (modifierActive) {
      selectToggle(h.item.path);
      lastAnchorIndex = h.idx;
      updateSelUI();
      renderList();
      return;
    }

    selected.clear();
    selected.add(h.item.path);
    lastAnchorIndex = h.idx;
    updateSelUI();
    renderList();
    if (h.item.type === 'dir') load(h.item.path); else openPreview(h.item.path);
  }, true);

  listEl.addEventListener('touchstart', (e)=>{
    if (e.target.closest('[data-menu]')) return;
    const h = itemFromEvent(e); if(!h) return;
    const t = e.touches[0]; if(!t) return;

    lastTouchedPath = h.item.path;
    touchStartX = t.clientX;
    touchStartY = t.clientY;
    dragSelecting = false;
    touchMoved = false;
    suppressNextClick = false;
    touchSelectionModifier = (e.touches.length > 1) || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey;
    pendingTouchSelectionToggle = touchSelectionModifier;

    clearLongPressTimer();
    const x = t.clientX + window.scrollX;
    const y = t.clientY + window.scrollY;
    lpTimer = setTimeout(()=>{
      lpTimer = null;
      lpFired = true;
      suppressNextClick = true;
      pendingTouchSelectionToggle = false;
      if(!selected.has(h.item.path)) {
        selected.clear();
        selected.add(h.item.path);
        lastAnchorIndex = h.idx;
        updateSelUI();
        renderList();
      }
      openCtx(h.item.path, x, y, h.item.type);
    }, 500);
  }, {passive:true});

  listEl.addEventListener('touchmove', (e)=>{
    if (!lastTouchedPath) return;
    const t = e.touches[0]; if(!t) return;

    const dx = t.clientX - touchStartX;
    const dy = t.clientY - touchStartY;
    if (!touchMoved && Math.sqrt(dx*dx + dy*dy) > DRAG_THRESHOLD) {
      touchMoved = true;
    }

    if (!touchMoved) return;

    clearLongPressTimer();
    if (lpFired) lpFired = false;

    const selectionIntent = touchSelectionModifier || dragSelecting || selected.size > 0;
    if (!selectionIntent) return;

    if (!dragSelecting) {
      dragSelecting = true;
      suppressNextClick = true;
      pendingTouchSelectionToggle = false;
      if (!touchSelectionModifier && selected.size === 0) {
        selected.clear();
      }
      selected.add(lastTouchedPath);
      updateSelUI();
    }

    const hit = document.elementFromPoint(t.clientX, t.clientY);
    const el = hit?.closest('[data-path]');
    if (el) {
      const path = el.getAttribute('data-path');
      if (path && !selected.has(path)) {
        selected.add(path);
        el.classList.add('selected');
        updateSelUI();
      }
    }

    e.preventDefault();
  }, {passive:false});

  const finishTouch = ()=>{
    clearLongPressTimer();
    if (dragSelecting) {
      updateSelUI();
      renderList();
    }
    if (touchMoved) suppressNextClick = true;
    dragSelecting = false;
    lastTouchedPath = null;
    touchSelectionModifier = false;
    touchMoved = false;
  };

  ['touchend','touchcancel'].forEach(evt=>{
    listEl.addEventListener(evt, finishTouch, {passive:true});
  });
}


/* ===== Keyboard niceties (desktop) ===== */
document.addEventListener('keydown', (e)=>{
  if(isTouch) return;
  if(e.key === 'Enter' && selected.size === 1){
    const p = [...selected][0];
    const it = filteredItems().find(i=>i.path===p);
    if(it){ if(it.type==='dir') load(p); else openPreview(p); }
  }
});

/* ===== History ===== */
window.addEventListener('popstate', (e)=>{
  const p = e.state?.path || '/';
  clearSelection();
  load(p, false);
});

/* ===== Preview modal ===== */
const previewEl    = document.getElementById('preview');
const previewBody  = document.getElementById('preview-body');
const previewTitle = document.getElementById('preview-title');
const previewClose = document.getElementById('preview-close');

function showPreview(title, innerHTML){
  previewTitle.textContent = title || '';
  previewBody.innerHTML = innerHTML;
  previewEl.classList.remove('hidden');
}
function closePreview(){
  previewBody.querySelectorAll('[data-bloburl]').forEach(n => {
    URL.revokeObjectURL(n.getAttribute('data-bloburl'));
  });
  previewEl.classList.add('hidden');
  previewBody.innerHTML = '';
}
previewClose.onclick = closePreview;
previewEl.addEventListener('click', (e)=>{ if(e.target === previewEl) closePreview(); });
document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape') closePreview(); });

async function blobURL(url){
  const res = await fetch(url);
  const blob = await res.blob();
  const u = URL.createObjectURL(blob);
  return u;
}
function escapeHTML(str){
  return str.replace(/[&<>"']/g, s=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[s]));
}
async function openPreview(path){
  const ext = (path.split('.').pop() || '').toLowerCase();
  const rawUrl = '/api/download?path='+encodeURIComponent(path);
  try{
    if(['png','jpg','jpeg','gif','webp','bmp','svg'].includes(ext)){
      const u = await blobURL(rawUrl);
      showPreview(path, `<img src="${u}" data-bloburl="${u}" class="max-h-[80vh] mx-auto rounded">`); return;
    }
    if(['mp4','webm','m4v','mov'].includes(ext)){
      const u = await blobURL(rawUrl);
      showPreview(path, `<video src="${u}" data-bloburl="${u}" controls autoplay class="max-h-[80vh] mx-auto rounded"></video>`); return;
    }
    if(['mp3','wav','ogg','m4a','flac'].includes(ext)){
      const u = await blobURL(rawUrl);
      showPreview(path, `<audio src="${u}" data-bloburl="${u}" controls autoplay class="w-full"></audio>`); return;
    }
    if(['txt','srt','ass','md','json','log','csv'].includes(ext)){
      const res = await fetch(rawUrl); const text = await res.text();
      showPreview(path, `<pre class="whitespace-pre-wrap text-left text-sm bg-[var(--muted)] p-3 rounded border border-[var(--border)]">${escapeHTML(text)}</pre>`); return;
    }
    window.open(rawUrl,'_blank');
  }catch{ window.open(rawUrl,'_blank'); }
}

/* ===== Uploads (queue + drag overlay) ===== */
const fileInput = document.getElementById('file');
const dropzone = document.getElementById('dropzone');
fileInput.addEventListener('change', ()=> enqueueFiles([...fileInput.files]));
['dragenter','dragover'].forEach(evt=>{
  window.addEventListener(evt, e=>{ e.preventDefault(); dropzone.classList.add('show'); });
});
['dragleave','drop'].forEach(evt=>{
  window.addEventListener(evt, e=>{ e.preventDefault(); dropzone.classList.remove('show'); });
});
dropzone.addEventListener('drop', (e)=>{
  const files = [...(e.dataTransfer?.files || [])];
  if(files.length) enqueueFiles(files);
});
let queue = []; let uploading = false;
function toastRow(name){
  const wrap = document.createElement('div');
  wrap.className = 'pointer-events-auto card rounded-2xl p-3 shadow-subtle';
  wrap.innerHTML = `<div class="text-sm truncate">${name}</div>
    <div class="mt-2 w-full h-2 bg-[var(--muted)] rounded"><div class="h-2 bg-[var(--accent)] rounded" style="width:0%"></div></div>
    <div class="text-right text-xs mt-1 opacity-80">0%</div>`;
  queueWrap.appendChild(wrap);
  return { wrap, bar: wrap.children[1].firstChild, pct: wrap.children[2] };
}
function enqueueFiles(files){
  files.forEach(f=>{
    const row = toastRow(f.name);
    queue.push({file:f, ...row});
  });
  if(!uploading) processQueue();
}
async function processQueue(){ uploading=true; while(queue.length){ const item=queue.shift(); await uploadOne(item); } uploading=false; load(currentPath); }
function uploadOne(item){
  return new Promise((resolve)=>{
    const fd = new FormData(); fd.append('file', item.file);
    const xhr = new XMLHttpRequest();
    xhr.open('POST', '/api/upload?path='+encodeURIComponent(currentPath));
    xhr.upload.onprogress = (e)=>{ if(!e.lengthComputable) return; const p=Math.round(e.loaded/e.total*100); item.bar.style.width=p+'%'; item.pct.textContent=p+'%'; };
    xhr.onload = ()=>{ item.bar.style.width='100%'; item.pct.textContent = (xhr.status>=200&&xhr.status<300)?'Done':'Error'; setTimeout(()=> item.wrap.remove(), 1800); resolve(); };
    xhr.onerror = ()=>{ item.pct.textContent='Error'; setTimeout(()=> item.wrap.remove(), 2200); resolve(); };
    xhr.send(fd);
  });
}

/* Up & mkdir */
document.getElementById('btn-up').onclick = ()=>{
  if(!currentPath || currentPath === '/') return;
  const parent = currentPath.split('/').slice(0,-1).join('/') || '/';
  clearSelection();
  load(parent);
};
document.getElementById('btn-mkdir').onclick = mkdirHere;

/* Actions (single or multi) */
function currentSelectionArray(){
  if(selected.size>0) return Array.from(selected);
  return ctxTarget ? [ctxTarget.path] : [];
}
function openItem(){
  const paths = currentSelectionArray();
  if(paths.length !== 1){ alert('Open/Preview is for a single item.'); return; }
  const p = paths[0];
  const it = filteredItems().find(i=>i.path===p) || {type:'file'};
  if(it.type==='dir') load(p); else openPreview(p);
}
async function propsItem(){
  const paths = currentSelectionArray();
  if(paths.length !== 1){ alert('Select exactly one item to view properties.'); return; }
  const j=await api('/api/properties?path='+encodeURIComponent(paths[0]));
  alert(`${j.type.toUpperCase()}\nName: ${j.name}\nSize: ${fmtBytes(j.size)}\nMIME: ${j.mime||''}\nModified: ${new Date(j.mtime*1000)}`);
}
async function mkdirHere(){
  const name=prompt('Folder name:'); if(!name) return;
  await api('/api/mkdir',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({parent: currentPath, name})});
  load(currentPath);
}
async function renameItem(){
  const paths = currentSelectionArray();
  if(paths.length !== 1){
    alert('Select exactly one item to rename.');
    return;
  }

  ctx.style.display='none';

  const src = paths[0];
  const trimmedSrc = src.replace(/\/+$/, '') || '/';
  if(trimmedSrc === '/'){
    alert('Cannot rename this item.');
    return;
  }

  const lastSlash = trimmedSrc.lastIndexOf('/');
  const parent = lastSlash <= 0 ? '/' : trimmedSrc.slice(0, lastSlash);
  const currentName = trimmedSrc.slice(lastSlash + 1);

  const input = prompt('New name:', currentName);
  if(input === null) return;
  const newName = input.trim();

  if(!newName){
    alert('Name cannot be empty.');
    return;
  }
  if(newName.includes('/')){
    alert('Name cannot contain "/" characters.');
    return;
  }
  if(newName === currentName) return;

  const dst = (parent === '/' ? '' : parent) + '/' + newName;

  try{
    await api('/api/move',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({src, dst})});
    selected.clear();
    updateSelUI();
    lastAnchorIndex = null;
    ctxTarget = null;
    load(currentPath);
  }catch(ex){
    alert('Rename failed: ' + ex.message);
  }
}
async function deleteItem(){
  const paths = currentSelectionArray(); if(paths.length===0) return;
  if(!confirm(`Delete ${paths.length} item(s)?`)) return;
  for(const p of paths){
    await api('/api/delete',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({path: p})});
  }
  clearSelection(); load(currentPath);
}
async function moveItem(){
  const paths = currentSelectionArray(); if(paths.length===0) return;
  const dst=prompt('Move to path (relative to root):', currentPath); if(!dst) return;
  for(const p of paths){
    await api('/api/move',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({src: p, dst})});
  }
  clearSelection(); load(currentPath);
}
async function copyItem(){
  const paths = currentSelectionArray(); if(paths.length===0) return;
  const dst=prompt('Copy to path (relative to root):', currentPath); if(!dst) return;
  for(const p of paths){
    await api('/api/copy',{method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({src: p, dst})});
  }
  clearSelection(); load(currentPath);
}
async function shareItem(){
  const paths = currentSelectionArray();
  if(paths.length !== 1){
    alert('Share works on one item at a time.');
    return;
  }
  const hours = prompt('Expires in hours (0 = never):', '0');
  if (hours === null) return; // User cancelled the prompt

  try {
    const j = await api('/api/share', {
      method: 'POST',
      headers: {'Content-Type': 'application/json'},
      body: JSON.stringify({path: paths[0], expires_hours: Number(hours || 0)})
    });
    const url = new URL(j.url, window.location.origin).toString();

    // --- New, reliable copy logic ---
    const copyToClipboard = (text) => {
      // Use navigator.clipboard if available (modern, secure)
      if (navigator.clipboard && window.isSecureContext) {
        return navigator.clipboard.writeText(text);
      } else {
        // Fallback for older browsers or insecure contexts
        let textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed"; // Avoid scrolling to bottom
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        return new Promise((res, rej) => {
          document.execCommand('copy') ? res() : rej();
          textArea.remove();
        });
      }
    };

    copyToClipboard(url)
      .then(() => alert('Share link copied to clipboard!\n' + url))
      .catch(() => alert('Could not copy link automatically. Please copy it manually:\n' + url));

  } catch (ex) {
    alert('Error creating share link: ' + ex.message);
  }
};


selDl.addEventListener('click', (e)=>{
  e.preventDefault();
  if (selDl.classList.contains('disabled')) return;
  downloadSelectedSequential();
});
selMv.addEventListener('click',  moveItem);
selCp.addEventListener('click',  copyItem);
selDel.addEventListener('click', deleteItem);
selClear.addEventListener('click', clearSelection);

/* Initial load */
history.replaceState({ path: startPath || '/' }, '', location.search || (startPath==='/'?'':'?path='+encodeURIComponent(startPath)));
load(startPath, false);
</script>
</body>
</html>
